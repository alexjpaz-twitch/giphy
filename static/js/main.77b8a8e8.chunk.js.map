{"version":3,"sources":["MediaPlayer.js","App.js","reportWebVitals.js","index.js"],"names":["logger","console","NOOP","MediaPlayerPlaylist","url","useState","queue","setQueue","currentUrl","setCurrentUrl","useEffect","info","q","length","shift","MediaPlayerElement","onEnd","videoRef","useRef","current","a","src","load","play","onend","startTime","Date","getTime","e","removeEventListener","addEventListener","ref","MediaPlayer","ConfigForm","class","for","href","type","name","placeholder","value","TwitchContainer","giphyKey","twitchChannel","gf","useMemo","GiphyFetch","setUrl","ComfyJS","onCommand","user","command","message","flags","extra","term","random","tag","rating","data","image_mp4_url","Init","Disconnect","App","urlParams","URLSearchParams","window","location","search","get","hasInteracted","setHasInteracted","Audio","className","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.77b8a8e8.chunk.js","sourcesContent":["import {\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\n\nconst logger = console;\nconst NOOP = () => {};\n\nconst MINIMUM_DURATION = 5 * 1000;\n\nexport function MediaPlayerPlaylist({ url }) {\n\n  const [ queue, setQueue ] = useState([]);\n\n  const [ currentUrl, setCurrentUrl ] = useState(null);\n\n  useEffect(() => {\n    logger.info(\"Queuing video\", url);\n    setQueue((q) => [...q, url]);\n  }, [ url ]);\n\n  useEffect(() => {\n    if(!currentUrl && queue.length > 0) {\n      const currentUrl = queue.shift();\n      setQueue([...queue]);\n      setCurrentUrl(currentUrl);\n    }\n\n  }, [ queue, currentUrl ]);\n\n  const onEnd = () => {\n    if(queue.length > 0) {\n      const currentUrl = queue.shift();\n      logger.info(\"Playing next video\", currentUrl);\n\n      setQueue([...queue]);\n\n      setCurrentUrl(currentUrl);\n    } else {\n\n      logger.info(\"End of the queue reached\");\n      setCurrentUrl(null);\n    }\n  };\n\n  if(!currentUrl) {\n    return null;\n  }\n\n  return (\n    <MediaPlayerElement url={currentUrl} onEnd={onEnd} />\n  )\n}\n\nexport function MediaPlayerElement({ url, onEnd = NOOP }) {\n  const videoRef = useRef(null);\n\n  useEffect(() => {\n    if(!videoRef.current) return;\n    if(!url) return;\n\n    (async function() {\n      videoRef.current.src = url;\n      await videoRef.current.load();\n      videoRef.current.play();\n\n      let onend = () => {};\n\n      let startTime = new Date().getTime();\n\n      onend = (e) => {\n        let endTime = new Date().getTime();\n\n        let duration = endTime - startTime;\n\n        if(duration <= MINIMUM_DURATION) {\n          logger.info(\"Duration not reached looping\");\n          videoRef.current.play();\n        } else {\n          logger.info(\"Duration reached ending\");\n          videoRef.current.src = null;\n          videoRef.current.removeEventListener(\"ended\", onend);\n          onEnd(url);\n        }\n      };\n\n      videoRef.current.addEventListener(\"ended\", onend);\n    })();\n  // TODO - I am obviously doing something \"bad\" but the \"good\" standard is preventing my intended behavior\n  /* eslint-disable react-hooks/exhaustive-deps */\n  }, [ videoRef, url ]);\n\n  return (\n    <video ref={videoRef}></video>\n  );\n}\n\nexport function MediaPlayer({ url }) {\n  return (\n    <MediaPlayerPlaylist url={url} />\n  );\n}\n\n","import './App.css';\n\nimport ComfyJS from 'comfy.js'\nimport { GiphyFetch } from '@giphy/js-fetch-api'\n\nimport { useMemo, useState, useEffect } from 'react'\n\nimport { MediaPlayer } from './MediaPlayer';\n\nconst logger = console;\n\nfunction App() {\n\n  // NOTE: For the Security Champions\n  // Yo, I know getting keys from URLs is bad news.\n  // But hear me out - for a toy project on twitch with a beta key\n  // that has a very low rate limit and can be easily regenerated?\n  // I'm not willing to spend the time, effort, and money.\n  // I think I can sleep at night knowing that there may be some\n  // potental hAx0rs getting the key. This application is not\n  // storing sensitive information that can be accessed by\n  // that Giphy API key.\n  const urlParams = new URLSearchParams(window.location.search);\n  const giphyKey = urlParams.get('giphyKey');\n  const twitchChannel = urlParams.get('twitchChannel');\n\n const [ hasInteracted, setHasInteracted ] = useState(false);\n\n  useEffect(() => {\n    if(!hasInteracted) {\n      // TEST IF WE CAN PROCEED\n      (async function() {\n        const a = new Audio();\n        try {\n          await a.play();\n          setHasInteracted(true);\n        } catch(e) {\n        }\n      })();\n\n      return;\n    }\n  });\n\n  if(!twitchChannel || !giphyKey) {\n    return (\n      <ConfigForm />\n    )\n  }\n\n  if(!hasInteracted) {\n    return <button onClick={e => setHasInteracted(true)}>CLICK ME</button>;\n  }\n\n  return (\n    <div className=\"App\">\n      <TwitchContainer giphyKey={giphyKey} twitchChannel={twitchChannel} />\n    </div>\n  );\n}\n\nfunction ConfigForm() {\n  return (\n    <form class='form'>\n      <div>\n        <label for='giphyKey'>\n          Giphy Key\n          (<a href='https://developers.giphy.com/dashboard/?create=true'>Create one</a>)\n        </label>\n        <input type='text' name='giphyKey' placeholder='Paste Giphy App Key' />\n      </div>\n      <div>\n        <label for='twitchChannel'>Twitch Channel</label>\n        <input type='text' name='twitchChannel' placeholder='Twitch Channel' />\n      </div>\n      <div>\n        <input type='submit' value='submit' />\n      </div>\n    </form>\n  );\n}\n\nfunction TwitchContainer({ giphyKey, twitchChannel }) {\n  const gf = useMemo(() => new GiphyFetch(giphyKey), [ giphyKey ]);\n\n  const [ url, setUrl ] = useState(null);\n\n  useEffect(() => {\n    ComfyJS.onCommand = async (user, command, message, flags, extra) => {\n      if(command === 'g') {\n        let term = message;\n\n        logger.info(`Searching for ${term}`);\n\n        const { data } = await gf.random({ tag: term, rating: 'pg-13' });\n        logger.info(\"Found\", data);\n\n\n        const url = data.image_mp4_url;\n\n        setUrl(url);\n      }\n    };\n\n    ComfyJS.Init(twitchChannel);\n\n    return () => {\n      ComfyJS.Disconnect();\n    };\n  }, [ gf, twitchChannel ]);\n\n  return (\n    <MediaPlayer url={url} />\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}