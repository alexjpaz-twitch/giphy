{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["logger","console","ConfigForm","class","for","href","type","name","placeholder","value","TwitchContainer","giphyKey","twitchChannel","gf","useMemo","GiphyFetch","useState","url","setUrl","useEffect","ComfyJS","onCommand","user","command","message","flags","extra","a","term","info","random","tag","rating","data","image_mp4_url","Init","Disconnect","MediaPlayer","videoRef","useRef","current","src","load","play","onend","startTime","Date","getTime","e","removeEventListener","addEventListener","ref","App","urlParams","URLSearchParams","window","location","search","get","hasInteracted","setHasInteracted","Audio","className","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.84649b5f.chunk.js","sourcesContent":["import './App.css';\n\nimport ComfyJS from 'comfy.js'\nimport { GiphyFetch } from '@giphy/js-fetch-api'\n\nimport { useMemo, useState, useEffect, useRef } from 'react'\n\nconst logger = console;\n\nfunction App() {\n\n  // NOTE: For the Security Champions\n  // Yo, I know getting keys from URLs is bad news.\n  // But hear me out - for a toy project on twitch with a beta key\n  // that has a very low rate limit and can be easily regenerated?\n  // I'm not willing to spend the time, effort, and money.\n  // I think I can sleep at night knowing that there may be some\n  // potental hAx0rs getting the key. This application is not\n  // storing sensitive information that can be accessed by\n  // that Giphy API key.\n  const urlParams = new URLSearchParams(window.location.search);\n  const giphyKey = urlParams.get('giphyKey');\n  const twitchChannel = urlParams.get('twitchChannel');\n\n const [ hasInteracted, setHasInteracted ] = useState(false);\n\n  useEffect(() => {\n    if(!hasInteracted) {\n      // TEST IF WE CAN PROCEED\n      (async function() {\n        const a = new Audio();\n        try {\n          await a.play();\n          setHasInteracted(true);\n        } catch(e) {\n        }\n      })();\n\n      return;\n    }\n  });\n\n  if(!twitchChannel || !giphyKey) {\n    return (\n      <ConfigForm />\n    )\n  }\n\n  if(!hasInteracted) {\n    return <button onClick={e => setHasInteracted(true)}>CLICK ME</button>;\n  }\n\n  return (\n    <div className=\"App\">\n      <TwitchContainer giphyKey={giphyKey} twitchChannel={twitchChannel} />\n    </div>\n  );\n}\n\nfunction ConfigForm() {\n  return (\n    <form class='form'>\n      <div>\n        <label for='giphyKey'>\n          Giphy Key\n          (<a href='https://developers.giphy.com/dashboard/?create=true'>Create one</a>)\n        </label>\n        <input type='text' name='giphyKey' placeholder='Paste Giphy App Key' />\n      </div>\n      <div>\n        <label for='twitchChannel'>Twitch Channel</label>\n        <input type='text' name='twitchChannel' placeholder='Twitch Channel' />\n      </div>\n      <div>\n        <input type='submit' value='submit' />\n      </div>\n    </form>\n  );\n}\n\nfunction TwitchContainer({ giphyKey, twitchChannel }) {\n  const gf = useMemo(() => new GiphyFetch(giphyKey), [ giphyKey ]);\n\n  const [ url, setUrl ] = useState(null);\n\n  useEffect(() => {\n    ComfyJS.onCommand = async (user, command, message, flags, extra) => {\n      if(command === 'g') {\n        let term = message;\n\n        logger.info(`Searching for ${term}`);\n\n        const { data } = await gf.random({ tag: term, rating: 'pg-13' });\n        logger.info(\"Found\", data);\n\n\n        const url = data.image_mp4_url;\n\n        setUrl(url);\n      }\n    };\n\n    ComfyJS.Init(twitchChannel);\n\n    return () => {\n      ComfyJS.Disconnect();\n    };\n  }, [ gf, twitchChannel ]);\n\n  return (\n    <MediaPlayer url={url} />\n  );\n}\n\nfunction MediaPlayer({ url }) {\n  const videoRef = useRef(null);\n\n  useEffect(() => {\n    if(!videoRef.current) return;\n    if(!url) return;\n\n    (async function() {\n      videoRef.current.src = url;\n      await videoRef.current.load();\n      videoRef.current.play();\n\n      let onend = () => {};\n\n      let MINIMUM_DURATION = 5 * 1000;\n\n      let startTime = new Date().getTime();\n\n      onend = (e) => {\n        let endTime = new Date().getTime();\n\n        let duration = endTime - startTime;\n\n        if(duration <= MINIMUM_DURATION) {\n          logger.info(\"Duration not reached looping\");\n          videoRef.current.play();\n        } else {\n          logger.info(\"Duration reached ending\");\n          videoRef.current.src = null;\n          videoRef.current.removeEventListener(\"ended\", onend);\n        }\n      };\n\n      videoRef.current.addEventListener(\"ended\", onend);\n    })();\n  }, [ videoRef, url ]);\n\n  return (\n    <video ref={videoRef}></video>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}